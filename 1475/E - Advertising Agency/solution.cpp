#include <bits/stdc++.h>using namespace std;// #include <ext/pb_ds/assoc_container.hpp>// #include <ext/pb_ds/tree_policy.hpp>// using namespace __gnu_pbds;// typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>pbds;#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL))#define ll long long#define int long long int#define pb push_back#define vll vector<ll>#define vpll vector<pair<ll, ll>>#define sll set<ll>#define mll map<ll, ll>#define F first#define S second#define fr(i, x, y) for (int i = x; i < y; i++)#define rfr(i, x, y) for (int i = n - 1; i >= 0; i--)#define ra(a, n) \    ll a[n];     \    fr(i, 0, n) cin >> a[i]#define rv(v, n)     \    vector<ll> v(n); \    fr(i, 0, n) cin >> v[i]#define debug(x) cout << #x << " " << x << '\n'#define endl "\n"#define Endl "\n"#define ENdl "\n"#define hae cout << "YES" << endl#define ds(xx) cout << xx << '\n';#define na cout << "NO" << endl#define all(x) x.begin(), x.end()#define rall(x) x.rbegin(), x.rend()#define setbit(x, k) (x |= (1LL << k))#define unsetbit(x, k) (x &= ~(1LL << k))#define checkbit(x, k) ((x >> k) & 1LL)const ll inf = 1e18;int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1};int dy[] = {0, 0, -1, 1, -1, 1, -1, 1};const int N = 1e5 + 10;const ll mod = 1e9 + 7; struct Mint{    int value;    static const int mod_value = mod;     Mint(long long v = 0)    {        value = v % mod;        if (value < 0)            value += mod;    }    Mint(long long a, long long b) : value(0)    {        *this += a;        *this /= b;    }     Mint &operator+=(Mint const &b)    {        value += b.value;        if (value >= mod)            value -= mod;        return *this;    }    Mint &operator-=(Mint const &b)    {        value -= b.value;        if (value < 0)            value += mod;        return *this;    }    Mint &operator*=(Mint const &b)    {        value = (long long)value * b.value % mod;        return *this;    }     friend Mint powermod(Mint a, long long e)    {        Mint res = 1;        while (e)        {            if (e & 1)                res *= a;            a *= a;            e >>= 1;        }        return res;    }    friend Mint inverse(Mint a) { return powermod(a, mod - 2); }     Mint &operator/=(Mint const &b) { return *this *= inverse(b); }    friend Mint operator+(Mint a, Mint const b) { return a += b; }    friend Mint operator-(Mint a, Mint const b) { return a -= b; }    friend Mint operator-(Mint const a) { return 0 - a; }    friend Mint operator*(Mint a, Mint const b) { return a *= b; }    friend Mint operator/(Mint a, Mint const b) { return a /= b; }    friend std::ostream &operator<<(std::ostream &os, Mint const &a) { return os << a.value; }    friend bool operator==(Mint const &a, Mint const &b) { return a.value == b.value; }    friend bool operator!=(Mint const &a, Mint const &b) { return a.value != b.value; }}; Mint ncr(int n, int r){    Mint res = 1;    for (int i = 1; i <= r; i++)    {        res *= Mint(n - i + 1);        res /= Mint(i);    }    return res;} void solve(Mint tc){    int n, k;    cin >> n >> k;    rv(v, n);    sort(rall(v));    int mn = v[k - 1];    int tot = count(all(v), mn);    int need = count(v.begin(), v.begin() + k, mn);    cout << ncr(tot, need) << '\n';} int32_t main(){    fastread();    ll T = 1;    cin >> T;    for (ll t = 1; t <= T; t++)        solve(t);    return 0;}